\chapter{Analíticas automáticas en Unibotics}
\label{analiticas}
En este capítulo se explica la recogida que se ha programado de las sondas en Unibotics, su posterior guardado en la base de datos Elasticsearch, la visualización de dichos datos con el entorno web Dash y la validación experimental del proceso completo.

\section{Diseño}
Para conseguir las analíticas automáticas en Unibotics, se han diseñado varios cambios en la plataforma con las nuevas tecnologías involucradas: Elasticsearch y Dash. Con estas extensiones estructurales se consigue la nueva funcionalidad de recogida y visualización automáticas de datos \\

\begin{figure}[H]
    \centering
    \includegraphics[width=9cm, keepaspectratio]{img/grafico.png}
    \caption{Antigua arquitectura de Unibotics}
    \label{fig:grafico}
\end{figure}

En la Figura \ref{fig:grafico} se presenta la arquitectura de Unibotics previa a este Trabajo de Fin de Grado. Como se describe en la sección 1.5, Unibotics está formado por un \textit{frontend}, donde se encuentra el cliente conectado a un contenedor RADI que tiene el simulador. La parte del \textit{backend} está compuesta por Django, el cual se conecta a la base de datos MySQL y a la nube de Amazon, S3.

\begin{figure}[H]
    \centering
    \includegraphics[width=14cm, keepaspectratio]{img/grafico2.png}
    \caption{Arquitectura Unibotics con las nuevas tecnologías}
    \label{fig:grafico2}
\end{figure}
La Figura \ref{fig:grafico2} muestra cómo es la arquitectura nueva de Unibotics después de este TFG. En la parte del \textit{frontend} se ha añadido la recogida de sondas con código JavaScript, al igual que las puntuaciones automáticas obtenidas por los estudiantes en algunos ejercicios. Además, está la página web de analíticas dónde se ven las gráficas. Por otro lado, en el \textit{backend} se ha añadido la base de datos Elasticsearch y la herramienta de Dash para generar esas visualizaciones.\\

Lo primero que hace un usuario cuando quiere entrar en la plataforma es registrarse en ella, guardando ese registro en la base de datos MySQL. Una vez registrado, podrá iniciar sesión en ella, en el momento que desee. Cuando se encuentre dentro de la plataforma, podrá elegir un ejercicio y acceder a él, dónde podrá programar la solución correspondiente. Dentro de los ejercicios algunos tienen la opción de pedir una evaluación automática de estilo y eficacia del código programado. Para abandonar la plataforma se puede cerrar sesión explícitamente o de manera implícita, cerrando el navegador o la pestaña.\\

Cuando un usuario interactúa con la plataforma de Unibotics, la herramienta de Elasticsearch recoge la información de estas interacciones, entrada y salida en la plataforma, en algún ejercicio, puntuaciones automáticas, etc. Las visualizaciones de las sondas recogidas se hacen a través de Dash, herramienta independiente a Django. Dash utiliza la base de datos de MySQL y la base de datos no relacional Elasticsearch.
\section{Recogida de sondas}
La primera parte de este proceso ha consistido en la programación de la recogida de diferentes sondas, detectándolas a través de código JavaScript. Una vez detectado la sonda es enviada al \textit{webserver}, el cual es el encargado de guardar la sonda en la base de datos, de modo persistente. Para realizar esta tarea, se ha decidido utilizar la base de datos Elasticsearch por las ventajas que ofrece, explicada en el capítulo 3.

\subsection{Tipos de sondas}
Las sondas, como ya se ha mencionado anteriormente, son los eventos interesantes que se quieren recoger. Este proyecto consta de cuatro tipos de sondas:
\begin{enumerate}
\item Entrada y salida de un usuario a la plataforma de Unibotics. Es útil para saber la duración de una sesión, de dónde procede cada usuario, qué sistema operativo utiliza y desde qué navegador entra a la plataforma.
\item Entrada y salida de un usuario a cada ejercicio que hay en la plataforma. Su principal utilidad es saber durante cuánto tiempo un usuario está realizando un ejercicio en concreto.
\item Puntuación automática de estilo que tiene el código fuente de un usuario para un ejercicio.
\item Puntuación automática de eficacia del código fuente de un usuario para un ejercicio.
\end{enumerate}
\newpage
\subsection{Base de datos de eventos interesantes}
Para definir y configurar los índices donde se guardarán las sondas, se ha creado un nuevo archivo, llamado \texttt{probe.py}. Al definir un índice, se determinan los nombres de cada campo (información que se quiere almacenar) y el tipo de campo que es, por ejemplo: un texto, un número, una fecha, entre otros. También se puede configurar el índice, por ejemplo, poniendo el número de\textit{ shards }o el número de réplicas. Un ejemplo de la definición de un índice sería este: \\

\begin{lstlisting}
   from django_elasticsearch_dsl import Document, Date, Text, Double
   
   class SessionDocument(Document):
    		username = Text()
  	  		start_date = Date()
   			end_date = Date()
    		duration = Double()
    		client_ip = Text()
    		browser = Text()
    		country = Text()
    		alpha_2 = Text()
    		alpha_3 = Text()
    		continent = Text()
    		class Index:
        		name = 'session_log'
        		settings = {
            			'number_of_shards': 1,
           				'number_of_replicas': 0
        }
\end{lstlisting} 
\\
Para este trabajo se han definido cuatro índices diferentes:

\begin{itemize}
\item \texttt{session\_log}: índice que recoge las sondas relativas a las sesiones. Consta de los campos de inicio y fin de sesión, duración de la sesión, la IP, el \textit{browser} (aporta información sobre el sistema operativo, navegador y dispositivo utilizado), el continente y país del usuario, así como el nombre del usuario.
\item \texttt{exercises\_log}: índice que recoge las sondas relativas a los diferentes ejercicios. Está compuesto por la fecha de entrada en un ejercicio, la fecha de salida, la duración total en el ejercicio, el nombre del ejercicio y el usuario.
\newpage
\item \texttt{style\_log}: índice que recoge los datos sobre la evaluación del estilo del código de los ejercicios que introducen los estudiantes. Este índice está formado por el campo de la fecha en la que se realiza la evaluación, el nombre del ejercicio, la puntuación sobre 100 y el nombre del usuario.
\item \texttt{efficacy\_log}: índice que recoge los datos sobre la evaluación de la eficacia del código de los ejercicios que introducen los estudiantes. Los campos son iguales que en el índice de \texttt{style\_log}.
\end{itemize}
\subsection{Detección de las sondas}
Las sondas se han detectado en el navegador we, en el \textit{frontend} con código JavaScript. La sonda número 1 de la subsección 4.2.1 ha sido capturada haciendo uso de la solicitud que se manda al \textit{webserver }al hacer \textit{login}. Cuando un usuario introduce su \textit{username}, su contraseña y clica en el botón de \textit{login}, se detecta la entrada del usuario. \\

Un usuario puede abandonar Unibotics de manera explícita, utilizando el botón de \textit{logout}, o de manera implícita, por inactividad. Cuando la salida es explícita se detecta en el mismo instante que clica en \textit{logout}.  Si no se detecta alguna pulsación del teclado o algún clic del ratón en la plataforma, durante un \textit{timeout} declarado de 30 minutos, se considerará que el usuario es inactivo. Pasado el \textit{timeout}, se detectará como salida del usuario.\\

La entrada a un ejercicio se detecta cuando se manda una petición de la vista de un ejercicio determinado al \textit{webserver}. La detección de la salida de un ejercicio ocurre cuando se llama a la vista de Django de liberar el docker. También se detecta si se está recargando el ejercicio o si sale directamente, ya que el docker se libera en ambas ocasiones.\\

Para detectar una recarga, se ha hecho uso del evento \textit{beforeunload}, qué detecta cuándo un usuario va a abandonar la página en la que se encuentra. En ese evento, aparte de llamar a la función que liberará el docker, se almacena en local la fecha en la que se ha activado el evento y el nombre del ejercicio. El código es el siguiente: \\
\newpage
\begin{lstlisting}
<script type="text/javascript">
   window.addEventListener("beforeunload", function (e) {
       e.preventDefault();
       var date = new Date().getTime();
       localStorage.setItem('lastTime', date);
       localStorage.setItem('exercise', '{{exercise}}');
       freeDocker();
   });
</script>
\end{lstlisting} 
Todos los ejercicios poseen el evento \textit{DOMContentLoaded}, el cual se activa cuando el documento HTML es cargado completamente. Una vez activado el evento, se comprueba si existe una fecha almacenada en local. La fecha representa cuándo fue la última vez que ese usuario ha entrado en un ejercicio. Si la dirección del ejercicio al que se accede contiene el nombre del ejercicio guardado anteriormente y, además, ha pasado menos de tres segundos desde que se accedió por última vez, se considera una recarga de página. A continuación, se muestra el código de detección de recarga.
\begin{lstlisting}
window.addEventListener("DOMContentLoaded", function (e) {
  console.log("Todos los recursos terminaron de cargar!");
  var current_location = window.location.href.split('/')
  var lastTime = localStorage.getItem('lastTime')
  var exercise = localStorage.getItem('exercise')
  if(lastTime){
   lastTime = Number(lastTime)
   var now = new Date().getTime();
   var difference = (now - lastTime)
   if (current_location[current_location.length-2]==exercise) {
     if(difference < 3*1000){
       reload()
     }
    }
  }
});
\end{lstlisting} 

Para detectar la puntuación recibida en la evaluación de eficacia se ha creado un nuevo botón en los ejercicios. Una vez pulsado el botón, empieza a ejecutar el código durante un tiempo determinado, según el ejercicio. Pasado ese tiempo se envía la nota obtenida del ejercicio al \textit{webserver}. Si el usuario pulsa una segunda vez a ese botón antes de que pase el tiempo de medición se considera que el usuario no desea la evaluación automática, por lo cual la sonda no se grabará. En la plataforma, ya constaba un botón de evaluación de estilo, el cual envía al \textit{webserver} el código fuente del ejercicio.

\subsection{Procesamiento y grabación de las sondas}
Una vez definidos en código fuente los diferentes índices, se importan al archivo \texttt{views.py} para poder crearlos. Las sesiones de los usuarios se guardan en el índice \texttt{session\_log}. A través de las sondas creadas, se recoge cuándo el usuario entra en la plataforma y cuándo finaliza su actividad en ella. Se recoge la sonda de la siguiente manera:
\\
\begin{lstlisting}
probe_session = SessionDocument(username=username,start_date=datetime.now(),
                                        end_date=datetime.now(),duration=0, client_ip=ip, 
                                        browser=request.META['HTTP_USER_AGENT'],
                                        country=location_info["country_name"],
                                        alpha_2=location_info["alpha_2"], 
                                        alpha_3=location_info["alpha_3"],
                                        continent=location_info["continent"])
probe_session.save()
\end{lstlisting}

Gracias al objeto \textit{HTTP Request} que recibe el fichero \texttt{views.py}, se obtiene la información del nombre del usuario, la IP y el \textit{user-agent}. En el \textit{user-agent} se encuentra el sistema operativo, el navegador o el dispositivo que utiliza el usuario para acceder a la web de Unibotics. Para la localización espacial se ha creado una función que, a partir de la IP, muestra la ubicación geográfica. Cuando el usuario entra, los campos de fin de sesión y duración se inicializan con la fecha actual y 0 respectivamente, una vez que el usuario haga \textit{logout} o finalice su sesión por inactividad estos campos se modificarán como se muestra a continuación:\\

\begin{lstlisting}
s = Search(index="session_log").query('match',username=request.user.username) \
        														.sort({"start_date": {'order':'desc'}})[0]
for hit in s:
    end = datetime.now()
    Elasticsearch(settings.ELASTICSEARCH_DSL['default']['hosts']) \
           .update(index="session_log", id=hit.meta.id,
             body={"doc": {'end_date': end,
                 'duration':(end - datetime.strptime(hit.start_date,'%Y%m%dT%H:%M:%S.%f')) \ 
                 .total_seconds()}})
\end{lstlisting}

Realizar los cálculos de la duración y la posición del usuario evita que a la hora de visualizarse se tengan que hacer dichos cálculos de todos los datos al mismo tiempo, ahorrando tiempo.\\
\newpage
Las sondas relativas a los ejercicios se guardan cuando el usuario accede a un ejercicio concreto. Como ocurre con las sesiones, cuando el usuario abandone el ejercicio se modificarán los datos de duración y fin del ejercicio. Se ha tenido en cuenta que al recargar un ejercicio se crea una nueva sonda no deseada. Dichas sondas se eliminan de la siguiente forma:\\
\\
\begin{lstlisting}
   es = Search(index="exercises_log").query('match', duration=0)  \
   				            .query('match', username=request.user.username)  \
        					                .sort({"start_date": {'order':'desc'}})
    for hit in es:
        Elasticsearch(settings.ELASTICSEARCH_DSL['default']['hosts'])  \ 
    				                        .delete(index="exercises_log", id=hit.meta.id)
\end{lstlisting}

En el \textit{webserver} se evalúa el código enviado con el botón de evaluación de estilo, dando unas recomendaciones para mejorar el estilo del código al usuario y una puntuación. La puntuación es recogida en el índice de \texttt{style\_log}. Por otro lado, la puntuación de eficacia es enviada al \textit{webserver} y se guarda directamente en el índice de \texttt{efficacy\_log}. \\

En este proceso de recogida de sondas y su grabación ha sido muy útil la utilización de la API que proporciona Elasticsearch para poder depurar y comprobar los datos que se estaban almacenando. Utilizando por ejemplo la URL    \newline       \texttt{http://127.0.0.1:9200/session\_log/\_search/?size=10000&pretty}, se comprueban las sondas de sesiones.\\
\subsection{Despliegue}
En este proyecto se ha utilizado la imagen de Docker de Elasticsearch debido a que permite que funcione en cualquier sistema operativo y replicar su instalación en cualquier máquina es directo. Primero hay que descargar la imagen de Elasticsearch con la versión deseada, en este caso se ha utilizado la 7.12.0. El comando para descargar la imagen es:
{\footnotesize
		\begin{verbatim}
			docker pull docker.elastic.co/elasticsearch/elasticsearch:7.12.0
		\end{verbatim}
		}
  \newpage
Para ejecutar el contenedor con la imagen descargada se utiliza el siguiente comando:

{\footnotesize
		\begin{verbatim}
			docker run --name=AcademyElastic -p 9200:9200 -p 9300:9300
            -e "discovery.type=single-node" 
            docker.elastic.co/elasticsearch/elasticsearch:7.12.0
		\end{verbatim}
		}

  Una vez puesto en marcha el contenedor de Elasticsearch, se tiene lanzada la base de datos donde se guardarán las sondas. Es posible realizar solicitudes directamente desde el navegador web accediendo a la URL donde esté desplegada la base de datos, por ejemplo: \texttt{http://localhost:9200/}.\\
  
   El siguiente paso es la integración de Elasticsearch en el servidor basado en Django. Para ello se hará uso de la librería \texttt{django-elasticsearch-dsl}. Además, se ha modificado el archivo de configuración del proyecto, \texttt{settings.py}. Se ha incluido la librería a las aplicaciones instaladas y creado una nueva variable, llamada \texttt{ELASTICSEARCH\_DSL}. Se ha añadido en \texttt{settings.py}, ya que las variables declaradas en ese fichero se pueden utilizar en cualquier parte del servidor. En esa variable se indica cuál es el servidor de Elasticsearch con el que se tiene que conectar y sincronizar.\\

Previamente, para comprobar el funcionamiento de Elasticsearch se generaron datos de prueba para comenzar a trabajar antes de tener los datos reales, los cuales lleva tiempo recoger. La base de datos \textit{Elasticsearch dummy} se ha creado gracias a las librerías de Python Faker\footnote{https://faker.readthedocs.io/en/master/} y Tornado\footnote{https://www.tornadoweb.org/en/stable/}, y en ella se pueden modificar las sondas. Por ejemplo, el número de sondas, de réplicas o de \textit{shards}. Esto ayudará a futuros desarrolladores a utilizar la base de datos Elasticsearch. En la Figura \ref{fig:dummy} se muestra el resultado de la sonda de evaluación de estilo de la base de datos de prueba.


\begin{figure}[H]
    \centering
    \includegraphics[width=6cm, keepaspectratio]{img/dummy.png}
    \caption{Elasticsearch dummy}
    \label{fig:dummy}
\end{figure}

\section{Visualización de la información}

Como se explica en el capítulo 3, Dash es un entorno web que permite crear tableros web interactivos con visualizaciones dinámicas, para poder hacer análisis. En este Trabajo de Fin de Grado se ha decidido utilizar esta herramienta para la visualización de las sondas recogidas en Elasticsearch.\\

Dash recibe los datos crudos guardados en Elasticsearch. Los datos se han recogido en producción desde el 5 de mayo de 2021. Como resultado se ha obtenido la información de usuarios reales desde esa fecha. Hay algunas visualizaciones que requieren de datos que no están guardados en Elasticsearch, por lo que Dash tiene que calcularlos. Por ejemplo, en algunas visualizaciones se representa la media por día, la cual tiene que calcularse.\\

En la plataforma de analíticas se podrá filtrar y agregar los datos que se representan. Se puede acceder a la plataforma de analíticas a través de la dirección https://analytics.unibotics.org/.\\

\begin{figure}[H]
    \centering
    \includegraphics[width=17cm, keepaspectratio]{img/esquemadash.png}
    \caption{Esquema de Dash}
    \label{fig:menu}
\end{figure}


Solo los usuarios registrados en Unibotics podrán acceder a las visualizaciones. Dependiendo del tipo de usuario, se tiene disponible unas visualizaciones u otras. Para que un administrador o un usuario normal inicie sesión en Dash, se ha hecho uso de los usuarios ya guardados en la base de datos MySQL de la que depende Django de Unibotics, en la que se encuentra la información sobre el tipo de usuario (\textit{staff}, \textit{admin}, \textit{user}...). En el caso de los administradores podrán ver la información de todas las sondas de todos los usuarios, de manera individual y principalmente de manera agregada, mientras que un usuario normal de Unibotics solo podrá acceder a las puntuaciones de estilo y de eficacia obtenidas en cada ejercicio por él mismo. La Figura \ref{fig:menu} muestra el menú disponible para los administradores.

\begin{figure}[H]
    \centering
    \includegraphics[width=3cm, keepaspectratio]{img/menu.png}
    \caption{Menú de un administrador en Dash}
    \label{fig:menu}
\end{figure}


Gracias a las bibliotecas de Dash, mencionadas en el capítulo 3, se ha dado estilo y formato a la aplicación web. También se ha hecho uso de las \textit{cookies }del navegador, guardadas al inicio de sesión de Dash, para comprobar si se está autorizado y si es un administrador de la plataforma.\\

Dash trabaja con \textit{dataframes}, por lo que es necesario realizar una primera transformación de los datos de Elasticsearch a esta estructura. Esta transformación se realiza gracias a la biblioteca Pandas. Un ejemplo de esta conversión es:

\begin{lstlisting}
  s = Search(using=es, index="session_log")
  results = [hit.to_dict() for hit in s.scan()]
  df  = pd.DataFrame(results)
\end{lstlisting}

\\
\\
\newpage
\subsection{Filtros habituales}
Con la biblioteca \texttt{dash\_core\_components} se han creado los filtros que algunas de las gráficas poseen. Estos filtros cambian de forma dinámica las visualizaciones en base a las opciones elegidas en dicho filtrado. Uno de los filtros que más se ha utilizado es el \textit{filtro por fechas}, estableciendo una fecha de inicio o de fin o ambas. Es posible conocer la situación de Unibotics en un periodo de tiempo concreto. El código de filtrado es:

\begin{lstlisting}
 if start_date is not None and end_date is not None:
        df=df.loc[(df['start_date'] > start_date) & (df['start_date'] <= end_date)]
elif start_date is not None:
        df=df.loc[(df['start_date'] > start_date)]
elif end_date is not None:
        df=df.loc[(df['start_date'] <= end_date)]
\end{lstlisting}
\\

Otro filtro recurrente en la mayoría de las visualizaciones es el \textit{filtro por usuario}. Este filtro solo aparece en las gráficas accesibles por los administradores, de forma que se puedan visualizar los datos de los diferentes usuarios concretos de la plataforma. Para este filtro se hace uso de las sondas de sesiones, recogiendo los nombres de los usuarios de forma única y añadiendo un 'Total' en los casos que se quiera visualizar las sondas de todos los usuarios. En resumen, el filtro podrá filtrar por usuario único, un grupo de usuarios o por el total de los usuarios, \newline\texttt{df = df[df.username.isin(user)]}. El código fuente creado para conseguir los nombres de los usuarios y añadir la opción de 'Total', es el siguiente:

\begin{lstlisting}
	s = Search(using=es, index="session_log")
    results = [hit.to_dict() for hit in s.scan()]
    df  = pd.DataFrame(results)
    df = df[df['username'].notna()]
    users = df['username'].unique()
    if not exercises:
        users = np.insert(users,0,'Total')
    return users
\end{lstlisting}
\\
\begin{figure}[H]
    \centering
    \includegraphics[width=16cm, keepaspectratio]{img/filtros.png}
    \caption{Filtros utilizados en Dash}
    \label{fig:filtros}
\end{figure}
\newpage
Dash utiliza el módulo Plotly para generar las visualizaciones. Plotly ofrece una gran variedad de gráficas que se pueden emplear en Dash. Adicionalmente se puede combinar varias gráficas en los mismos ejes, haciendo más sencilla la correlación entre datos.\\

\\
En las siguientes subsecciones se detallan los resultados de las analíticas que se han programado para este TFG con datos de usuarios reales de la plataforma de Unibotics. Se muestran las diferentes gráficas creadas tanto para administradores como para los usuarios normales, así como una explicación de lo que representan.
\subsection{Visualización del número de registros y usuarios de la plataforma}
Los administradores tienen la opción de ver el número total de usuarios activos, que se definen como aquellos que han iniciado sesión en los últimos 2 meses. Además, se muestran las gráficas de línea de registros por cada día, registros acumulados por días (Figura \ref{fig:accumulated}) y usuarios activos (Figura \ref{fig:active}). Cada una de estas gráficas contiene su propio filtrado por fechas.\\

Para la gráfica de usuarios activos, empezando por la primera sesión recogida en \texttt{session\_log} hasta el día actual, se comprueba cuántos usuarios han iniciado sesión desde 2 meses atrás hasta el día que se está comprobando. El código fuente para crear una gráfica de línea es el siguiente, en este caso del número de usuarios activos por día:

\begin{lstlisting}
def get_temporal_figure_active_users(df):
    fig = px.line(df, x='Date', y='Active Users')
    fig.add_trace(go.Scatter(x=df["Date"].tolist(), 
                             y=df["Active Users"].tolist(),
                             mode="markers", textposition="top center", 
                             name="Active Users",
                             text=df["Active Users"].tolist()))
return fig
\end{lstlisting}
\\

Las gráficas de las Figuras \ref{fig:users} y \ref{fig:accumulated} han sido elaboradas con la base de datos MySQL. Se ha realizado una lista de todas las fechas de los registros en Unibotics. Esta lista se ha convertido en \textit{dataframes}. Se ha contado el número de repeticiones de cada fecha y su acumulación, dando como resultado dichas gráficas.\\
\newpage
En marzo, la Figura \ref{fig:users} refleja el registro de los alumnos de "Visión en Robótica" en el Master de visión artificial URJC, curso 2020-2021. Y la subida de septiembre-octubre refleja el registro de los estudiantes de "Robótica móvil" y "Robótica de servicio" en el grado de Ingeniería Robótica Software, curso 2021-2022.



\begin{figure}[H]
    \centering
    \includegraphics[width=14cm, keepaspectratio]{img/users.png}
    \caption{Gráficas relativas a los usuarios}
    \label{fig:users}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width=14cm, keepaspectratio]{img/accumulated.png}
    \caption{Gráfica registro de usuarios acumulado}
    \label{fig:accumulated}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width=15cm, keepaspectratio]{img/active.png}
    \caption{Gráfica de evolución de usuarios activos cada día}
    \label{fig:active}
\end{figure}
En la Figura \ref{fig:active}) se muestra cómo en los meses de verano han disminuido los usuarios activos. Esto se debe a la finalización de los periodos lectivos de la universidad, donde se utiliza Unibotics.\\

En todas las gráficas de Dash si se pone el cursor sobre uno de los puntos se puede ver la información con mayor detalle, como se muestra en la Figura \ref{fig:users}. Además, Dash añade varias opciones para interactuar con la gráfica, por ejemplo, se puede descargar la gráfica, hacer \textit{zoom} o seleccionar una parte de ella. \\
\subsection{Visualización de actividad en la plataforma Unibotics}

La gráfica creada que se muestra en la Figura \ref{fig:sesion} representa en el eje X el tiempo y en el eje Y el número de sesiones, dando como resultado una gráfica de línea, con énfasis en los puntos para una mejor visualización. Esta gráfica muestra el número de sesiones iniciales por día. En la gráfica se observa qué días ha habido más \textit{logins}, viéndose cómo en los meses de verano dicho número se ha reducido. Hace uso del índice \texttt{session\_log}, contando cuántas veces el campo \textit{start\_date} se repite.\\



\begin{figure}[H]
    \centering
    \includegraphics[width=16cm, keepaspectratio]{img/sesion.png}
    \caption{Gráfico sesiones totales por día}
    \label{fig:sesion}
\end{figure}
Se ha creado otra gráfica lineal de sesiones por día, pero en este caso solo se tiene en cuenta una sesión al día como máximo por cada usuario, es decir se mide el número de usuarios únicos que han entrado en Unibotics en cada día. La gráfica está creada de la misma manera que la gráfica del total de sesiones por día y con los mismos filtros (fechas y usuarios). Para que sean usuarios únicos, se ha eliminado los\textit{ dataframes} cuya columna de \textit{username} se repetía. En la Figura \ref{fig:sesion_users}  se muestra una parte ampliada de dicha gráfica.\\

\begin{figure}[H]
    \centering
    \includegraphics[width=16cm, keepaspectratio]{img/sesion_users.png}
    \caption{Gráfico sesiones únicas por día}
    \label{fig:sesion_users}
\end{figure}
\newpage
La Figura \ref{fig:time} muestra una gráfica de barras en la cual se representa el tiempo mediante el eje X y la duración total de la sesión de los usuarios en minutos en el eje Y. Además, se ha incluido una línea que representa la duración media de las sesiones. Aquí podemos comprobar que a veces la media coincide con la duración total debido a que solo ha habido una sesión en ese día. Para realizar esta gráfica se han utilizado los campos de \textit{duration} y \textit{start\_date} del índice \texttt{session\_log}. Para crear la gráfica de barras junto con la gráfica de línea de la media, se utiliza el siguiente código:

\begin{lstlisting}
def get_temporal_figure__session_time(df):
    fig = px.bar(df, x='start_date', y='duration')
    fig.add_trace(go.Scatter(x=df['start_date'], 
                              y=df['mean'], 
                              line=dict(color='red'), 
                              name='Mean'),
                  row=1, col=1)
    return fig
\end{lstlisting}

\begin{figure}[H]
    \centering
    \includegraphics[width=16cm, keepaspectratio]{img/time.png}
    \caption{Gráfico de tiempo de uso en Unibotics}
    \label{fig:time}
\end{figure}
Esta gráfica se puede filtrar tanto por fechas como por usuarios, pudiendo ver el tiempo dedicado de un usuario y la media total del tiempo en minutos que usa Unibotics dicho usuario, como se puede ver en la Figura \ref{fig:time_user}.

\begin{figure}[H]
    \centering
    \includegraphics[width=17cm, keepaspectratio]{img/time_user.png}
    \caption{Gráfico de tiempo en Unibotics de un usuario concreto}
    \label{fig:time_user}
\end{figure}

A fin de poder hacer un análisis de la media, la desviación típica o la moda se ha creado un histograma de las duraciones de las sesiones, como se ve en la Figura \ref{fig:time_user}. En el eje X, se encuentran los diferentes intervalos de duraciones de los usuarios. En el eje Y, representa cuántos usuarios han utilizado la plataforma durante el mismo tiempo. Para hacer el histograma de duración, se ha programado el código:
\begin{lstlisting}
def get_temporal_figure__histogram_time(df):
    fig = px.histogram(df, x='duration')
    fig.update_layout(bargap=0.1)
return fig
\end{lstlisting}

\begin{figure}[H]
    \centering
    \includegraphics[width=15cm, keepaspectratio]{img/time_histogram.png}
    \caption{Histograma de las duraciones de sesiones}
    \label{fig:time_histogram}
\end{figure}
\newpage
Con el propósito de conocer el tiempo que invierten los usuarios \textit{en cada ejercicio} se ha elaborado un histograma de las duraciones de los ejercicios. Esta gráfica dispone de un filtro del ejercicio que se desea comprobar, con el filtro de usuario y el de fechas. Por ejemplo, la Figura \ref{fig:histogram_exercise} es un histograma del ejercicio \textit{follow\_line}  de un grupo de usuarios y unas fechas concretas. Para realizar el histograma, se ha utilizado el índice de \texttt{exercises\_log}, en concreto los campos de \textit{exercise} y \textit{duration}.

\begin{figure}[H]
    \centering
    \includegraphics[width=17cm, keepaspectratio]{img/histogram_exercise.png}
    \caption{Histograma del ejercicio \texttt{follow\_line } de un grupo de usuarios }
    \label{fig:histogram_exercise}
\end{figure}

La Figura \ref{fig:activity} representa un mapa de calor con la actividad de los usuarios. Estas gráficas están inspiradas en las que usa GitHub para mostrar la actividad de un desarrollador de software en sus repositorios. Está dividido en cuadrados que representan cada día de un año, cuanto más intenso es el color verde más sesiones ha habido. A medida que disminuyen las sesiones la intensidad también baja. Aparte del filtrado por fechas, tiene un filtro por usuario para ver la actividad por usuarios únicos o un grupo de ellos. Como ocurría con la gráfica lineal de sesiones, el primer mapa de color cuenta el total de las sesiones y el segundo mapa de color cuenta las sesiones únicas por usuario. Las sesiones se han contado a través del campo de \textit{start\_date} del índice de \texttt{session\_log}. En las gráficas se refleja como en los periodos lectivos hay una mayor actividad que en verano.\\




\begin{figure}[H]
    \centering
    \includegraphics[width=18cm, keepaspectratio]{img/activity.png}
    \caption{Mapas de calor sesiones}
    \label{fig:activity}
\end{figure}

\subsection{Visualización de los metadatos de los usuarios}
En la Figura \ref{fig:mundo} se muestra un mapa geográfico con la localización espacial  de los usuarios que acceden a Unibotics. La gráfica está preparada para cuando Unibotics incorpore usuarios de todas las partes del mundo. El tamaño de los puntos depende de la cantidad de sesiones, cuanto mayor sea el punto más sesiones hay. A la derecha se encuentra una leyenda con los países, se puede seleccionar uno o varios países en la leyenda para que solo se vean ellos en el mapa. Se puede filtrar por fechas. Para esta gráfica se han necesitado los campos de \textit{country}, \textit{continent} y \textit{alpha\_3} (código de los países), del índice de \texttt{session\_log}. Para hacer el mapa se ha programado el siguiente código fuente:
\\
\begin{lstlisting}
def get_temporal_figure__country(df):
    fig = px.scatter_geo(df, locations="alpha_3", color="country",
                     hover_name="country", size="count",
                     projection="natural earth")
return fig
\end{lstlisting}


\begin{figure}[H]
    \centering
    \includegraphics[width=17cm, keepaspectratio]{img/mundo.png}
    \caption{Mapa geográfico de sesiones}
    \label{fig:mundo}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width=12cm, keepaspectratio]{img/españa.png}
    \caption{Mapa geográfico de sesiones de España}
    \label{fig:mundo}
\end{figure}
La Figura \ref{fig:browser} trata de una gráfica con los distintos navegadores que utilizan los usuarios para acceder a Unibotics, en formato porcentajes. En este caso se ve que una gran parte de inicio de sesiones es a través del navegador de Chrome. 


\begin{figure}[H]
    \centering
    \includegraphics[width=18cm, keepaspectratio]{img/browser.png}
    \caption{Gráfico de navegadores usados por los estudiantes}
    \label{fig:browser}
\end{figure}
Se ha creado una gráfica similar a la anterior para representar los Sistemas Operativos utilizados por los usuarios que acceden a Unibotics, como se puede ver en la Figura \ref{fig:os}. Ambas gráficas tienen filtro por fechas.\\

En ambas gráficas circulares se ha hecho uso del campo \textit{browser} del índice de \texttt{session\_log}, el cual da la información sobre el sistema operativo y el navegador utilizado. Para realizar dichas gráficas circulares se programa el siguiente código:
\begin{lstlisting}
def get_temporal_figure__browser(df):
    fig = px.pie(df, values='count', names='browser')
return fig
\end{lstlisting}

\begin{figure}[H]
    \centering
    \includegraphics[width=15cm, keepaspectratio]{img/os.png}
    \caption{Gráfico de sistemas operativos}
    \label{fig:os}
\end{figure}
\subsection{Visualizaciones de las puntuaciones automáticas}
Las siguientes gráficas son las puntuaciones de estilo y eficacia que podrán ser vistas tanto por los usuarios (que pueden acceder a sus propias puntuaciones) como por los administradores (que pueden acceder a las puntuaciones de todos los usuarios).  Actualmente, las evaluaciones solo están disponibles en cuatro ejercicios. Se representa en una gráfica en la que cada punto es una evaluación solicitada por el usuario. Las gráficas mostradas en las Figuras \ref{fig:score} y \ref{fig:score_efficacy}  son un ejemplo de las notas de estilo y eficacia de un usuario de la base de datos de prueba en el ejercicio \textit{follow\_line}. Las gráficas de los demás ejercicios son iguales. Para crear estas gráficas se utilizan todos los campos del índice de \texttt{style\_log} y \texttt{efficacy\_log}. El código de ambas gráficas es:
\begin{lstlisting}
def score_fig(df):
    fig = px.scatter(df, x="date", y="score")
return fig
\end{lstlisting}




\begin{figure}[H]
    \centering
    \includegraphics[width=17cm, keepaspectratio]{img/score.png}
    \caption{Gráfica de puntuación de estilo}
    \label{fig:score}
\end{figure}


\begin{figure}[H]
    \centering
    \includegraphics[width=17cm, keepaspectratio]{img/score_efficacy.png}
    \caption{Gráfica de puntuación de eficacia}
    \label{fig:score_efficacy}
\end{figure}
\subsection{Despliegue}
Para desplegar Dash en producción se ha añadido su contenedor al \textit{docker compose} del sistema Unibotics. Se indica el puerto por el cual va a ser lanzado y las dependencias entre servicios, en este caso entre Dash y Elasticsearch. El código es el siguiente:\\


\begin{lstlisting}
dash:
        image: unibotics
        working_dir: /unibotics-webserver/unibotics_dash
        restart: always
        ports:
            - "6123:6123"
        container_name: "dash_unibotics"
        command: gunicorn -w 1 -b :6123 app:server
        environment:
            - ELASTICSEARCH_HOST=elasticsearch
        depends_on:
            - elasticsearch
\end{lstlisting} 
